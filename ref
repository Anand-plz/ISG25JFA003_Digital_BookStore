// book entity 
package com.libraryManagement.project.entity;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "books")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "book_id")
    private Long bookId;

    @NotBlank
    @Column(name = "title", nullable = false)
    private String title;

    @ManyToOne
    @JoinColumn(name = "author_id", nullable = false)
    private Author author;

    @ManyToOne
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @NotNull
    @Positive
    @Column(name = "price", nullable = false)
    private Double price;

    private int stockQuantity;

    @Column(nullable = false)
    private Boolean active = true;

    @Column(name = "image_url")
    private String imageUrl;

    public Book(String title, Author author, Category category, Double price, int stockQuantity, String imageUrl){
        this.title = title;
        this.author = author;
        this.category = category;
        this.price = price;
        this.stockQuantity = stockQuantity;
        this.imageUrl = imageUrl;
    }
}

// book request dto
package com.libraryManagement.project.dto.requestDTO;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class BookRequestDTO {
    @NotNull(message= "Title cannot be null")
    private String title;

    @NotNull(message = "Author Name cannot be null")
    private String authorName;

    @NotNull(message = "Category Name cannot be null")
    private String categoryName;

    @NotNull(message = "Price cannot be null")
    @Positive(message = "Price must be positive")
    private Double price;

    private int stockQuantity;
    private String imageUrl;

    public BookRequestDTO(String title, String author, String category) {
        this.title = title;
        this.authorName = author;
        this.categoryName = category;
    }
}

// book response dto
package com.libraryManagement.project.dto.responseDTO;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class BookResponseDTO {
    private Long bookId;
    private String title;
    private String authorName;
    private String categoryName;
    private Double price;
    private int stockQuantity;
    private String imageUrl;

    public BookResponseDTO(Long bookId, @NotBlank String title, @NotNull String authorName,
                           @NotNull String categoryName, @NotNull @Positive Double price,
                           int stockQuantity, String imageUrl) {
        this.bookId = bookId;
        this.title = title;
        this.authorName = authorName;
        this.categoryName = categoryName;
        this.price = price;
        this.stockQuantity = stockQuantity;
        this.imageUrl = imageUrl;
    }

}

// book repository
package com.libraryManagement.project.repository;

import com.libraryManagement.project.entity.Author;
import com.libraryManagement.project.entity.Book;
import com.libraryManagement.project.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface BookRepository extends JpaRepository<Book, Long> {
    List<Book> findByAuthorAuthorId(Long authorId);

//    Optional<Book> findByTitle(String name);
    boolean existsByAuthor_AuthorId(Long authorId);
    boolean existsByCategory_CategoryId(Long categoryId);
    List<Book> findByCategoryCategoryId(Long categoryId);
    List<Book> findByTitleContainingIgnoreCase(String title);
    List<Book> findByAuthorNameContainingIgnoreCase(String authorName);
    List<Book> findByCategoryNameContainingIgnoreCase(String categoryName);
    boolean existsByTitleAndAuthorAndCategory(String title, Author author, Category category);
}

// book service
package com.libraryManagement.project.service;

import com.libraryManagement.project.dto.requestDTO.BookRequestDTO;
import com.libraryManagement.project.dto.responseDTO.BookResponseDTO;
import com.libraryManagement.project.entity.Book;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;


public interface BookService {
    List<BookResponseDTO> getAllBooks();

    BookResponseDTO getBookById(Long id);

    List<BookResponseDTO> getBooksByAuthor(Long authorId);

    List<BookResponseDTO> getBooksByCategory(Long categoryId);

    List<BookResponseDTO> findBooksByTitle(String title);

    List<BookResponseDTO> findBooksByAuthor(String authorName);

    List<BookResponseDTO> findBooksByCategory(String categoryName);

    @Transactional
    BookResponseDTO addBook(BookRequestDTO bookRequestDTO);

    @Transactional
    BookResponseDTO updateBook(Long id, BookRequestDTO bookRequestDTO);

    @Transactional
    void deleteBook(Long id);

    default Book convertToEntity(BookRequestDTO bookRequestDTO) {
        return new Book(bookRequestDTO.getTitle(), null, null, bookRequestDTO.getPrice(),bookRequestDTO.getStockQuantity(),bookRequestDTO.getImageUrl());
    }

    default BookResponseDTO convertToResponseDTO(Book book) {
        return new BookResponseDTO(book.getBookId(), book.getTitle(), book.getAuthor().getName(), book.getCategory().getName(), book.getPrice(), book.getStockQuantity(),book.getImageUrl());
    }
}

// book service impl

package com.libraryManagement.project.service.impl;

import com.libraryManagement.project.dto.requestDTO.BookRequestDTO;
import com.libraryManagement.project.dto.responseDTO.BookResponseDTO;
import com.libraryManagement.project.entity.*;
import com.libraryManagement.project.exception.BookNotFoundException;
import com.libraryManagement.project.repository.*;
import com.libraryManagement.project.service.BookService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class BookServiceImpl implements BookService {

    private final BookRepository bookRepository;
    private final AuthorRepository authorRepository;
    private final CategoryRepository categoryRepository;
    private final InventoryRepository inventoryRepository;
    private final CartItemsRepository cartItemsRepository;
    private final OrderItemsRepository orderItemsRepository;
    private final CartRepository cartRepository;

    @Override
    public List<BookResponseDTO> getAllBooks() {
        return bookRepository.findAll().stream()
                .filter(book -> book.getActive() == null || book.getActive())
                .map(this::convertToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public BookResponseDTO getBookById(Long id) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));
        return convertToResponseDTO(book);
    }

    @Override
    public List<BookResponseDTO> getBooksByAuthor(Long authorId) {
        if (!authorRepository.existsById(authorId)) {
            throw new BookNotFoundException("Author not found with ID: " + authorId);
        }

        List<Book> books = bookRepository.findByAuthorAuthorId(authorId);
        if (books.isEmpty()) {
            throw new BookNotFoundException("No books found for author ID: " + authorId);
        }

        return books.stream().map(this::convertToResponseDTO).collect(Collectors.toList());
    }

    @Override
    public List<BookResponseDTO> getBooksByCategory(Long categoryId) {
        if (!categoryRepository.existsById(categoryId)) {
            throw new BookNotFoundException("Category not found with ID: " + categoryId);
        }

        List<Book> books = bookRepository.findByCategoryCategoryId(categoryId);
        if (books.isEmpty()) {
            throw new BookNotFoundException("No books found for category ID: " + categoryId);
        }

        return books.stream().map(this::convertToResponseDTO).collect(Collectors.toList());
    }

    @Override
    public List<BookResponseDTO> findBooksByTitle(String title) {
        return bookRepository.findByTitleContainingIgnoreCase(title).stream()
                .map(this::convertToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<BookResponseDTO> findBooksByAuthor(String authorName) {
        return bookRepository.findByAuthorNameContainingIgnoreCase(authorName).stream()
                .map(this::convertToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<BookResponseDTO> findBooksByCategory(String categoryName) {
        return bookRepository.findByCategoryNameContainingIgnoreCase(categoryName).stream()
                .map(this::convertToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public BookResponseDTO addBook(BookRequestDTO bookRequestDTO) {
        Author author = authorRepository.findByName(bookRequestDTO.getAuthorName())
                .orElseGet(() -> {
                    Author newAuthor = new Author();
                    newAuthor.setName(bookRequestDTO.getAuthorName());
                    return authorRepository.save(newAuthor);
                });

        Category category = categoryRepository.findByName(bookRequestDTO.getCategoryName())
                .orElseGet(() -> {
                    Category newCategory = new Category();
                    newCategory.setName(bookRequestDTO.getCategoryName());
                    return categoryRepository.save(newCategory);
                });

        boolean exists = bookRepository.existsByTitleAndAuthorAndCategory(
                bookRequestDTO.getTitle(), author, category);
        if (exists) {
            throw new IllegalArgumentException("Book already exists in the database.");
        }

        Book book = convertToEntity(bookRequestDTO);
        book.setAuthor(author);
        book.setCategory(category);

        Book savedBook = bookRepository.save(book);

        Inventory inventory = new Inventory();
        inventory.setBook(savedBook);
        inventory.setStockQuantity(savedBook.getStockQuantity());
        inventoryRepository.save(inventory);

        return convertToResponseDTO(savedBook);
    }

    @Transactional
    @Override
    public BookResponseDTO updateBook(Long id, BookRequestDTO bookRequestDTO) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));

        Author author = authorRepository.findByName(bookRequestDTO.getAuthorName())
                .orElseGet(() -> {
                    Author newAuthor = new Author();
                    newAuthor.setName(bookRequestDTO.getAuthorName());
                    return authorRepository.save(newAuthor);
                });

        Category category = categoryRepository.findByName(bookRequestDTO.getCategoryName())
                .orElseGet(() -> {
                    Category newCategory = new Category();
                    newCategory.setName(bookRequestDTO.getCategoryName());
                    return categoryRepository.save(newCategory);
                });

        book.setTitle(bookRequestDTO.getTitle());
        book.setPrice(bookRequestDTO.getPrice());
        book.setStockQuantity(bookRequestDTO.getStockQuantity());
        book.setAuthor(author);
        book.setCategory(category);
        book.setImageUrl(bookRequestDTO.getImageUrl());

        Book updatedBook = bookRepository.save(book);

        inventoryRepository.findByBook(updatedBook).ifPresent(inventory -> {
            inventory.setStockQuantity(updatedBook.getStockQuantity());
            inventoryRepository.save(inventory);
        });

        return convertToResponseDTO(updatedBook);
    }

    @Transactional
    @Override
    public void deleteBook(Long id) {
        Book book = bookRepository.findById(id)
                .orElseThrow(() -> new BookNotFoundException("Book not found with ID: " + id));

        boolean isInOrders = orderItemsRepository.existsByBookId(book.getBookId());
        if (isInOrders) {
            book.setActive(false);
            bookRepository.save(book);
        } else {
            removeBookFromAllCarts(id);
            inventoryRepository.findByBook(book).ifPresent(inventoryRepository::delete);
            bookRepository.delete(book);
        }
    }

    private void removeBookFromAllCarts(Long bookId) {
        List<CartItems> cartItems = cartItemsRepository.findBookByBookId(bookId);
        for (CartItems item : cartItems) {
            Cart cart = item.getCart();
            cart.removeCartItem(item);
            cart.setUpdatedAt(LocalDateTime.now());
            cartRepository.save(cart);
            cartItemsRepository.delete(item);
        }
    }

    // Dummy conversion methods (replace with ModelMapper or actual logic)
    public BookResponseDTO convertToResponseDTO(Book book) {
        BookResponseDTO dto = new BookResponseDTO();
        dto.setBookId(book.getBookId());
        dto.setTitle(book.getTitle());
        dto.setPrice(book.getPrice());
        dto.setStockQuantity(book.getStockQuantity());
        dto.setAuthorName(book.getAuthor().getName());
        dto.setCategoryName(book.getCategory().getName());
        dto.setImageUrl(book.getImageUrl());
        return dto;
    }

    public Book convertToEntity(BookRequestDTO dto) {
        Book book = new Book();
        book.setTitle(dto.getTitle());
        book.setPrice(dto.getPrice());
        book.setStockQuantity(dto.getStockQuantity());
        book.setImageUrl(dto.getImageUrl());
        return book;
    }
}

